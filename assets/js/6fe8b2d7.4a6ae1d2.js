"use strict";(self.webpackChunkdot_net_from_zero_by_soheil_karami=self.webpackChunkdot_net_from_zero_by_soheil_karami||[]).push([[663],{7004:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Contents/Session 1/Variables-types/Type-Casting-and-Conversion-","title":"Type Casting and Conversion","description":"In C#, you can convert one data type into another using two main techniques:","source":"@site/docs/Contents/Session 1/01-Variables-types/03-Type-Casting-and-Conversion-.md","sourceDirName":"Contents/Session 1/01-Variables-types","slug":"/Contents/Session 1/Variables-types/Type-Casting-and-Conversion-","permalink":"/DotNet-From-Zero-by-Soheil-Karami/docs/Contents/Session 1/Variables-types/Type-Casting-and-Conversion-","draft":false,"unlisted":false,"editUrl":"https://github.com/sohilww/DotNet-From-Zero-by-Soheil-Karami/docs/Contents/Session 1/01-Variables-types/03-Type-Casting-and-Conversion-.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Type Casting and Conversion","sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Variables, Types","permalink":"/DotNet-From-Zero-by-Soheil-Karami/docs/Contents/Session 1/Variables-types/Variables-types"},"next":{"title":"Null, Value Types, Reference Types, and Nullable Types","permalink":"/DotNet-From-Zero-by-Soheil-Karami/docs/Contents/Session 1/Variables-types/Null-ValueTypes-ReferenceTypes-and-Nullable-Types"}}');var t=s(4848),r=s(8453);const d={title:"Type Casting and Conversion",sidebar_position:3},l="Type Casting and Conversion",c={},a=[{value:"\ud83d\udd39 Implicit Casting (Safe Casting)",id:"-implicit-casting-safe-casting",level:2},{value:"\ud83e\uddee Data Types Size and Range",id:"-data-types-size-and-range",level:2},{value:"\ud83d\udd39 Explicit Casting (Manual Casting)",id:"-explicit-casting-manual-casting",level:2},{value:"\ud83d\udd39 Using Convert Class",id:"-using-convert-class",level:2},{value:"\ud83d\udd39 Using Parse and TryParse",id:"-using-parse-and-tryparse",level:2},{value:"\ud83d\udccc Summary",id:"-summary",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"type-casting-and-conversion",children:"Type Casting and Conversion"})}),"\n",(0,t.jsx)(n.p,{children:"In C#, you can convert one data type into another using two main techniques:"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-implicit-casting-safe-casting",children:"\ud83d\udd39 Implicit Casting (Safe Casting)"}),"\n",(0,t.jsxs)(n.p,{children:["This is done ",(0,t.jsx)(n.strong,{children:"automatically"})," when there is no risk of data loss. For example, from ",(0,t.jsx)(n.code,{children:"int"})," to ",(0,t.jsx)(n.code,{children:"double"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"int myInt = 42;\ndouble myDouble = myInt;\nConsole.WriteLine(myDouble); // Output: 42\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-data-types-size-and-range",children:"\ud83e\uddee Data Types Size and Range"}),"\n",(0,t.jsxs)(n.p,{children:["Understanding the ",(0,t.jsx)(n.strong,{children:"size and range"})," of data types is essential before performing any casting operation. Here's a quick comparison:"]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Size"}),(0,t.jsx)(n.th,{children:"Range"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"byte"})}),(0,t.jsx)(n.td,{children:"Unsigned 8-bit integer"}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"0 to 255"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"sbyte"})}),(0,t.jsx)(n.td,{children:"Signed 8-bit integer"}),(0,t.jsx)(n.td,{children:"1 byte"}),(0,t.jsx)(n.td,{children:"-128 to 127"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"short"})}),(0,t.jsx)(n.td,{children:"Signed 16-bit integer"}),(0,t.jsx)(n.td,{children:"2 bytes"}),(0,t.jsx)(n.td,{children:"-32,768 to 32,767"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ushort"})}),(0,t.jsx)(n.td,{children:"Unsigned 16-bit integer"}),(0,t.jsx)(n.td,{children:"2 bytes"}),(0,t.jsx)(n.td,{children:"0 to 65,535"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"int"})}),(0,t.jsx)(n.td,{children:"Signed 32-bit integer"}),(0,t.jsx)(n.td,{children:"4 bytes"}),(0,t.jsx)(n.td,{children:"-2,147,483,648 to 2,147,483,647"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"uint"})}),(0,t.jsx)(n.td,{children:"Unsigned 32-bit integer"}),(0,t.jsx)(n.td,{children:"4 bytes"}),(0,t.jsx)(n.td,{children:"0 to 4,294,967,295"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"long"})}),(0,t.jsx)(n.td,{children:"Signed 64-bit integer"}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ulong"})}),(0,t.jsx)(n.td,{children:"Unsigned 64-bit integer"}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"0 to 18,446,744,073,709,551,615"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"float"})}),(0,t.jsx)(n.td,{children:"Single-precision floating-point number"}),(0,t.jsx)(n.td,{children:"4 bytes"}),(0,t.jsx)(n.td,{children:"\xb11.5 \xd7 10\u207b\u2074\u2075 to \xb13.4 \xd7 10\xb3\u2078"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"double"})}),(0,t.jsx)(n.td,{children:"Double-precision floating-point number"}),(0,t.jsx)(n.td,{children:"8 bytes"}),(0,t.jsx)(n.td,{children:"\xb15.0 \xd7 10\u207b\xb3\xb2\u2074 to \xb11.7 \xd7 10\xb3\u2070\u2078"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"decimal"})}),(0,t.jsx)(n.td,{children:"High-precision decimal (ideal for currency)"}),(0,t.jsx)(n.td,{children:"16 bytes"}),(0,t.jsx)(n.td,{children:"\xb11.0 \xd7 10\u207b\xb2\u2078 to \xb17.9 \xd7 10\xb2\u2078"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"char"})}),(0,t.jsx)(n.td,{children:"Unicode character"}),(0,t.jsx)(n.td,{children:"2 bytes"}),(0,t.jsx)(n.td,{children:"U+0000 to U+FFFF"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["Having this in mind helps you understand why ",(0,t.jsxs)(n.strong,{children:["casting from ",(0,t.jsx)(n.code,{children:"double"})," to ",(0,t.jsx)(n.code,{children:"int"})," may lose precision"]}),", or why ",(0,t.jsxs)(n.strong,{children:["you can safely cast from ",(0,t.jsx)(n.code,{children:"int"})," to ",(0,t.jsx)(n.code,{children:"long"})," but not always the reverse"]}),"."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-explicit-casting-manual-casting",children:"\ud83d\udd39 Explicit Casting (Manual Casting)"}),"\n",(0,t.jsxs)(n.p,{children:["This is needed when you're converting a ",(0,t.jsx)(n.strong,{children:"larger or more precise"})," type to a smaller one, which may cause data loss. You use parentheses to cast manually."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"double pi = 3.14;\nint whole = (int)pi;\nConsole.WriteLine(whole); // Output: 3\n"})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"double largeValue = 123456.789;\nint smaller = (int)largeValue;\nConsole.WriteLine(smaller); // Output: 123456 (fraction lost)\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-using-convert-class",children:"\ud83d\udd39 Using Convert Class"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Convert"})," class provides methods like ",(0,t.jsx)(n.code,{children:"Convert.ToInt32"}),", ",(0,t.jsx)(n.code,{children:"Convert.ToDouble"}),", etc. It is ",(0,t.jsx)(n.strong,{children:"safer"})," than direct casting, and it throws exceptions on failure."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string priceText = "199";\nint price = Convert.ToInt32(priceText);\nConsole.WriteLine(price); // Output: 199\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-using-parse-and-tryparse",children:"\ud83d\udd39 Using Parse and TryParse"}),"\n",(0,t.jsxs)(n.p,{children:["Used for converting ",(0,t.jsx)(n.strong,{children:"strings to numeric types"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Parse"})," throws an exception if input is invalid"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"TryParse"})," returns a ",(0,t.jsx)(n.code,{children:"bool"})," and doesn't throw an exception"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string input = "123";\nint result = int.Parse(input);\nConsole.WriteLine(result); // Output: 123\n'})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'string input = "abc";\nbool success = int.TryParse(input, out int value);\nConsole.WriteLine($"Success: {success}, Value: {value}");\n// Output: Success: False, Value: 0\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-summary",children:"\ud83d\udccc Summary"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Method"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Safe?"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Implicit Casting"}),(0,t.jsx)(n.td,{children:"Automatically done if safe"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Explicit Casting"}),(0,t.jsx)(n.td,{children:"Manual, may lose data"}),(0,t.jsx)(n.td,{children:"\u26a0\ufe0f Risky"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Convert Class"}),(0,t.jsx)(n.td,{children:"Static methods for conversions"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Parse"}),(0,t.jsx)(n.td,{children:"Parses string, throws on failure"}),(0,t.jsx)(n.td,{children:"\u274c No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"TryParse"}),(0,t.jsx)(n.td,{children:"Tries parsing, returns success/failure"}),(0,t.jsx)(n.td,{children:"\u2705 Yes"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var i=s(6540);const t={},r=i.createContext(t);function d(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);